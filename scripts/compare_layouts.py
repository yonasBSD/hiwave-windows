#!/usr/bin/env python3
"""
compare_layouts.py - Compare RustKit layout against Chromium oracle DOMRects

This script compares the layout boxes generated by RustKit against the
DOMRect data extracted from Chromium to identify layout discrepancies.

Usage:
    python3 scripts/compare_layouts.py <run_dir> [--verbose] [--max-delta <px>]
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

def load_json(path: Path) -> Optional[Dict[str, Any]]:
    """Load JSON file if it exists."""
    if path.exists():
        with open(path) as f:
            return json.load(f)
    return None

def flatten_layout_tree(node: Dict[str, Any], depth: int = 0) -> List[Dict[str, Any]]:
    """Flatten a RustKit layout tree into a list of boxes."""
    boxes = []
    
    box_type = node.get("type", "unknown")
    
    if box_type == "text":
        rect = node.get("rect", {})
        boxes.append({
            "type": "text",
            "text": node.get("text", ""),
            "depth": depth,
            "rect": rect
        })
    else:
        content_rect = node.get("content_rect", {})
        margin_box = node.get("margin_box", {})
        
        boxes.append({
            "type": box_type,
            "depth": depth,
            "content_rect": content_rect,
            "margin_box": margin_box
        })
    
    for child in node.get("children", []):
        boxes.extend(flatten_layout_tree(child, depth + 1))
    
    return boxes

def match_boxes_to_elements(
    rustkit_boxes: List[Dict[str, Any]],
    chromium_elements: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Match RustKit boxes to Chromium elements based on position similarity.
    
    This is a heuristic matching since we don't have element IDs.
    """
    matches = []
    
    # For text boxes, try to match by text content
    rustkit_text_boxes = [b for b in rustkit_boxes if b["type"] == "text"]
    chromium_text_runs = [e for e in chromium_elements if "text" in str(e)]
    
    # For block boxes, match by approximate position
    rustkit_block_boxes = [b for b in rustkit_boxes if b["type"] == "block"]
    chromium_block_elements = [
        e for e in chromium_elements 
        if e.get("style", {}).get("display") in ["block", "flex", "grid", None]
    ]
    
    return matches

def compare_rects(
    rustkit_rect: Dict[str, float],
    chromium_rect: Dict[str, float]
) -> Dict[str, float]:
    """Compare two rectangles and return deltas."""
    return {
        "delta_x": abs(rustkit_rect.get("x", 0) - chromium_rect.get("x", 0)),
        "delta_y": abs(rustkit_rect.get("y", 0) - chromium_rect.get("y", 0)),
        "delta_width": abs(rustkit_rect.get("width", 0) - chromium_rect.get("width", 0)),
        "delta_height": abs(rustkit_rect.get("height", 0) - chromium_rect.get("height", 0)),
    }

def is_in_viewport(rect: Dict[str, float], viewport_width: float, viewport_height: float) -> bool:
    """Check if a rectangle is at least partially inside the viewport."""
    x = rect.get("x", 0)
    y = rect.get("y", 0)
    w = rect.get("width", 0)
    h = rect.get("height", 0)
    
    # Box is in viewport if any part of it overlaps
    return (x + w > 0 and x < viewport_width and
            y + h > 0 and y < viewport_height)

def analyze_case(
    case_id: str,
    rustkit_layout: Dict[str, Any],
    chromium_oracle: Dict[str, Any],
    in_viewport_only: bool = True
) -> Dict[str, Any]:
    """Analyze a single case comparing RustKit layout to Chromium oracle."""
    
    result = {
        "case_id": case_id,
        "rustkit_viewport": rustkit_layout.get("viewport", {}),
        "chromium_viewport": chromium_oracle.get("viewport", {}),
        "rustkit_box_count": 0,
        "chromium_element_count": len(chromium_oracle.get("elements", [])),
        "in_viewport_only": in_viewport_only,
        "issues": [],
        "in_viewport_issues": [],
        "below_fold_issues": []
    }
    
    # Flatten RustKit layout tree
    if "root" in rustkit_layout:
        rustkit_boxes = flatten_layout_tree(rustkit_layout["root"])
        result["rustkit_box_count"] = len(rustkit_boxes)
    else:
        result["issues"].append("No root in RustKit layout")
        return result
    
    chromium_elements = chromium_oracle.get("elements", [])
    
    # Check viewport match
    rk_vp = result["rustkit_viewport"]
    cr_vp = result["chromium_viewport"]
    if rk_vp.get("width") != cr_vp.get("width") or rk_vp.get("height") != cr_vp.get("height"):
        result["issues"].append(f"Viewport mismatch: RustKit {rk_vp} vs Chromium {cr_vp}")
    
    vp_w = rk_vp.get("width", 1280)
    vp_h = rk_vp.get("height", 800)
    
    # Analyze RustKit layout for potential issues
    in_viewport_count = 0
    below_fold_count = 0
    
    for box in rustkit_boxes:
        rect = box.get("content_rect") or box.get("rect", {})
        x, y = rect.get("x", 0), rect.get("y", 0)
        w, h = rect.get("width", 0), rect.get("height", 0)
        
        in_vp = is_in_viewport(rect, vp_w, vp_h)
        
        if in_vp:
            in_viewport_count += 1
        else:
            below_fold_count += 1
        
        # Check for zero-size boxes (always an issue)
        if w == 0 and h == 0 and box["type"] not in ["text", "anonymous_block"]:
            issue = f"Zero-size {box['type']} box at depth {box['depth']}"
            if in_vp:
                result["in_viewport_issues"].append(issue)
            else:
                result["below_fold_issues"].append(issue)
        
        # Check for elements completely outside viewport
        if x > vp_w or y > vp_h:
            issue = f"Box outside viewport: x={x:.0f}, y={y:.0f}"
            if in_vp:
                result["in_viewport_issues"].append(issue)
            else:
                result["below_fold_issues"].append(issue)
        
        # Check for mispositioned elements (x=0, y=0 when they shouldn't be)
        if x == 0 and y == 0 and box["depth"] > 1 and w > 0 and h > 0:
            # This could be a flex positioning issue
            if box["type"] in ["form_control", "block"] and box["depth"] > 2:
                issue = f"Potential mispositioned {box['type']} at (0,0) depth={box['depth']}"
                if in_vp:
                    result["in_viewport_issues"].append(issue)
                else:
                    result["below_fold_issues"].append(issue)
    
    result["in_viewport_box_count"] = in_viewport_count
    result["below_fold_box_count"] = below_fold_count
    
    # Compare text runs if available
    chromium_text_runs = chromium_oracle.get("textRuns", [])
    rustkit_text_boxes = [b for b in rustkit_boxes if b["type"] == "text"]
    
    result["chromium_text_runs"] = len(chromium_text_runs)
    result["rustkit_text_boxes"] = len(rustkit_text_boxes)
    
    # Text count mismatch might indicate layout issues
    if abs(len(chromium_text_runs) - len(rustkit_text_boxes)) > 5:
        result["issues"].append(
            f"Text count mismatch: Chromium {len(chromium_text_runs)} vs RustKit {len(rustkit_text_boxes)}"
        )
    
    # Combine issues based on filtering mode
    if in_viewport_only:
        result["issues"].extend(result["in_viewport_issues"])
    else:
        result["issues"].extend(result["in_viewport_issues"])
        result["issues"].extend(result["below_fold_issues"])
    
    return result

def classify_issue(issue: str) -> str:
    """Classify an issue into a category for WorkOrder routing."""
    issue_lower = issue.lower()
    
    if "zero-size" in issue_lower or "mispositioned" in issue_lower:
        if "form_control" in issue_lower:
            return "flex-form-controls"
        return "flex-positioning"
    
    if "outside viewport" in issue_lower:
        return "layout-overflow"
    
    if "text count mismatch" in issue_lower:
        return "text-layout"
    
    if "viewport mismatch" in issue_lower:
        return "capture-size"
    
    return "unknown"

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 scripts/compare_layouts.py <run_dir> [--verbose]")
        sys.exit(1)
    
    run_dir = Path(sys.argv[1])
    verbose = "--verbose" in sys.argv
    
    if not run_dir.exists():
        print(f"Error: Run directory not found: {run_dir}")
        sys.exit(1)
    
    rustkit_dir = run_dir / "rustkit"
    oracle_dir = run_dir / "oracle"
    
    print(f"Comparing layouts from: {run_dir}")
    print()
    
    results = []
    issue_categories = {}
    
    for layout_file in rustkit_dir.glob("*.layout.json"):
        case_id = layout_file.stem.replace(".layout", "")
        oracle_file = oracle_dir / f"{case_id}.oracle.json"
        
        rustkit_layout = load_json(layout_file)
        chromium_oracle = load_json(oracle_file)
        
        if not rustkit_layout:
            print(f"  {case_id}: SKIP (no RustKit layout)")
            continue
        
        if not chromium_oracle:
            print(f"  {case_id}: SKIP (no Chromium oracle)")
            continue
        
        result = analyze_case(case_id, rustkit_layout, chromium_oracle)
        results.append(result)
        
        # Classify issues
        for issue in result["issues"]:
            category = classify_issue(issue)
            if category not in issue_categories:
                issue_categories[category] = []
            issue_categories[category].append({
                "case_id": case_id,
                "issue": issue
            })
        
        issue_count = len(result["issues"])
        status = "OK" if issue_count == 0 else f"{issue_count} issues"
        
        print(f"  {case_id}: {result['rustkit_box_count']} boxes, {result['chromium_element_count']} elements, {status}")
        
        if verbose and result["issues"]:
            for issue in result["issues"][:5]:
                print(f"    - {issue}")
    
    # Save results
    report_path = run_dir / "layout_comparison.json"
    with open(report_path, "w") as f:
        json.dump({
            "run_dir": str(run_dir),
            "cases": results,
            "issue_categories": issue_categories,
            "summary": {
                "total": len(results),
                "with_issues": sum(1 for r in results if r["issues"]),
                "total_issues": sum(len(r["issues"]) for r in results),
                "categories": {cat: len(issues) for cat, issues in issue_categories.items()}
            }
        }, f, indent=2)
    
    print()
    print(f"Report saved to: {report_path}")
    
    # Summary
    total_issues = sum(len(r["issues"]) for r in results)
    cases_with_issues = sum(1 for r in results if r["issues"])
    
    print()
    print(f"Summary: {cases_with_issues}/{len(results)} cases have issues, {total_issues} total issues")
    
    # Print category breakdown
    if issue_categories:
        print()
        print("Issue Categories:")
        for cat, issues in sorted(issue_categories.items(), key=lambda x: -len(x[1])):
            print(f"  {cat}: {len(issues)} issues")

if __name__ == "__main__":
    main()

