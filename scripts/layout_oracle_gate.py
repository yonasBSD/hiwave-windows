#!/usr/bin/env python3
"""
layout_oracle_gate.py - Compare RustKit layout against Chromium oracle DOMRects

This script compares the layout boxes generated by RustKit against the
DOMRect data extracted from Chromium to identify layout discrepancies.

Usage:
    python3 scripts/layout_oracle_gate.py <run_dir> [--verbose]
"""

import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

def load_oracle(oracle_path: Path) -> Optional[Dict[str, Any]]:
    """Load Chromium oracle data."""
    if oracle_path.exists():
        with open(oracle_path) as f:
            return json.load(f)
    return None

def extract_layout_from_rustkit(perf_path: Path) -> Optional[Dict[str, Any]]:
    """
    Extract layout information from RustKit.
    
    Currently this is limited since we don't dump the full layout tree.
    In the future, we should add a --dump-layout flag to hiwave-smoke.
    """
    # For now, return None - we'll need to add layout dumping to RustKit
    return None

def compare_element_rects(
    chromium_elements: List[Dict[str, Any]],
    rustkit_elements: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Compare element rectangles between Chromium and RustKit.
    
    Returns comparison results with per-element deltas.
    """
    results = {
        "total_elements": len(chromium_elements),
        "matched": 0,
        "mismatched": 0,
        "missing": 0,
        "max_delta": 0.0,
        "avg_delta": 0.0,
        "deltas": []
    }
    
    # For now, we can only compare Chromium elements
    # since we don't have RustKit layout export yet
    for elem in chromium_elements:
        rect = elem.get("rect", {})
        delta_info = {
            "tag": elem.get("tagName"),
            "id": elem.get("id"),
            "class": elem.get("className"),
            "chromium_rect": rect,
            "rustkit_rect": None,  # TODO: Match with RustKit
            "delta_x": 0,
            "delta_y": 0,
            "delta_width": 0,
            "delta_height": 0,
            "total_delta": 0
        }
        results["deltas"].append(delta_info)
    
    return results

def analyze_layout_issues(oracle: Dict[str, Any]) -> Dict[str, Any]:
    """
    Analyze the Chromium oracle to identify potential layout issues.
    
    This looks for patterns that might indicate RustKit layout bugs:
    - Elements with negative positions
    - Elements outside viewport
    - Zero-size elements
    - Overlapping siblings
    """
    issues = {
        "negative_positions": [],
        "outside_viewport": [],
        "zero_size": [],
        "viewport": oracle.get("viewport", {})
    }
    
    viewport_width = issues["viewport"].get("width", 1280)
    viewport_height = issues["viewport"].get("height", 800)
    
    for elem in oracle.get("elements", []):
        rect = elem.get("rect", {})
        x, y = rect.get("x", 0), rect.get("y", 0)
        w, h = rect.get("width", 0), rect.get("height", 0)
        
        elem_info = {
            "tag": elem.get("tagName"),
            "id": elem.get("id"),
            "class": elem.get("className"),
            "rect": rect
        }
        
        # Check for negative positions
        if x < 0 or y < 0:
            issues["negative_positions"].append(elem_info)
        
        # Check for elements outside viewport
        if x > viewport_width or y > viewport_height:
            issues["outside_viewport"].append(elem_info)
        
        # Check for zero-size elements (excluding inline elements)
        if w == 0 and h == 0:
            style = elem.get("style", {})
            if style.get("display") not in ["inline", "contents"]:
                issues["zero_size"].append(elem_info)
    
    return issues

def generate_layout_report(run_dir: Path, verbose: bool = False) -> Dict[str, Any]:
    """Generate a layout comparison report for all cases in a run."""
    
    oracle_dir = run_dir / "oracle"
    
    report = {
        "run_dir": str(run_dir),
        "cases": [],
        "summary": {
            "total_cases": 0,
            "analyzed": 0,
            "with_issues": 0
        }
    }
    
    for oracle_file in oracle_dir.glob("*.oracle.json"):
        case_id = oracle_file.stem.replace(".oracle", "")
        report["summary"]["total_cases"] += 1
        
        oracle = load_oracle(oracle_file)
        if not oracle:
            continue
        
        report["summary"]["analyzed"] += 1
        
        # Analyze layout issues
        issues = analyze_layout_issues(oracle)
        
        case_report = {
            "id": case_id,
            "element_count": len(oracle.get("elements", [])),
            "text_run_count": len(oracle.get("textRuns", [])),
            "issues": {
                "negative_positions": len(issues["negative_positions"]),
                "outside_viewport": len(issues["outside_viewport"]),
                "zero_size": len(issues["zero_size"])
            },
            "viewport": issues["viewport"]
        }
        
        if verbose:
            case_report["issue_details"] = issues
        
        has_issues = any(v > 0 for v in case_report["issues"].values())
        if has_issues:
            report["summary"]["with_issues"] += 1
        
        report["cases"].append(case_report)
    
    return report

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 scripts/layout_oracle_gate.py <run_dir> [--verbose]")
        sys.exit(1)
    
    run_dir = Path(sys.argv[1])
    verbose = "--verbose" in sys.argv
    
    if not run_dir.exists():
        print(f"Error: Run directory not found: {run_dir}")
        sys.exit(1)
    
    print(f"Analyzing layout from: {run_dir}")
    
    report = generate_layout_report(run_dir, verbose)
    
    # Save report
    report_path = run_dir / "layout_analysis.json"
    with open(report_path, "w") as f:
        json.dump(report, f, indent=2)
    
    print(f"\nLayout Analysis Report")
    print(f"======================")
    print(f"Total cases: {report['summary']['total_cases']}")
    print(f"Analyzed: {report['summary']['analyzed']}")
    print(f"With issues: {report['summary']['with_issues']}")
    print(f"\nReport saved to: {report_path}")
    
    # Print per-case summary
    print(f"\nPer-case summary:")
    for case in report["cases"]:
        issues = case["issues"]
        issue_str = ", ".join(f"{k}={v}" for k, v in issues.items() if v > 0)
        if not issue_str:
            issue_str = "none"
        print(f"  {case['id']}: {case['element_count']} elements, issues: {issue_str}")

if __name__ == "__main__":
    main()

